/*
    Generator for the SMOKE sources
    Copyright (C) 2009 Arno Rehn <arno@arnorehn.de>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include <QCoreApplication>
#include <QDir>
#include <QFile>
#include <QMap>
#include <QSet>
#include <QTextStream>

#include <type.h>

#include "globals.h"

void writeClass(QTextStream& out, const Class* klass);

void writeClassFiles()
{
    // how many classes go in one file
    int count = classIndex.count() / parts;
    int count2 = count;
    
    QList<QString> keys = classIndex.keys();
    
    for (int i = 0; i < parts; i++) {
        QSet<QString> includes;
        QString classCode;
        QTextStream classOut(&classCode);
        
        // write the class code to a QString so we can later prepend the #includes
        if (i == parts - 1) count2 = -1;
        foreach (const QString& str, keys.mid(count * i, count2)) {
            const Class* klass = &classes[str];
            includes.insert(klass->fileName());
            writeClass(classOut, klass);
        }
        
        // create the file
        QFile file(outputDir.filePath("x_" + QString::number(i + 1) + ".cpp"));
        file.open(QFile::ReadWrite | QFile::Truncate);

        QTextStream fileOut(&file);
        
        // write out the header
        fileOut << "//Auto-generated by " << QCoreApplication::arguments()[0] << ". DO NOT EDIT.\n";
        fileOut << "#include <smoke.h>\n#include <" << module << "_smoke.h>\n";

        // ... and the #includes
        QList<QString> sortedIncludes = includes.toList();
        qSort(sortedIncludes.begin(), sortedIncludes.end());
        foreach (const QString& str, sortedIncludes) {
            fileOut << "#include <" << str << ">\n";
        }

        // now the class code
        fileOut << "\n" << classCode;
        
        file.close();
    }
}

QString stackItemField(const Type* type)
{
    if (type->pointerDepth() > 0 || !type->isIntegral())
        return "s_class";
    if (type->getEnum())
        return "s_enum";
    
    QString typeName = type->name();
    typeName.replace("unsigned ", "u");
    typeName.replace("signed ", "");
    return "s_" + typeName;
}

QString assignmentString(const Type* type, const QString& var)
{
    if (type->pointerDepth() > 0) {
        return "(void*)" + var;
    } else if (type->isIntegral()) {
        return var;
    } else if (type->isRef()) {
        return "(void*)&" + var;
    } else {
        QString ret = "(void*)new ";
        if (Class* retClass = type->getClass())
            ret += retClass->toString();
        else if (Typedef* retTdef = type->getTypedef())
            ret += retTdef->toString(); 
        else
            ret += type->name();
        ret += "(xret)";
        return ret;
    }
    return QString();
}

void generateMethod(QTextStream& out, const QString& className, const Method& meth, int index)
{
    out << "    ";
    if (meth.flags() & Method::Static)
        out << "static ";
    out << QString("void x_%1(Smoke::Stack x) {\n").arg(index + 1);
    out << "        // " << meth.toString() << "\n";
    out << "        ";
    if (meth.type() != Type::Void)
        out << meth.type()->toString() << " xret = ";
    if (!(meth.flags() & Method::Static))
        out << "this->";
    out << className << "::" << meth.name() << "(";
    for (int j = 0; j < meth.parameters().count(); j++) {
        const Parameter& param = meth.parameters()[j];
        if (j > 0) out << ",";
        out << "(" << param.toString() << ")" << "x[" << j + 1 << "]." << stackItemField(param.type());
    }
    out << ");\n";
    if (meth.type() != Type::Void) {
        out << "        x[0]." << stackItemField(meth.type()) << " = " << assignmentString(meth.type(), "xret") << ";\n";
    } else {
        out << "        (void)x; // noop (for compiler warning)\n";
    }
    out << "    }\n";
}

void generateVirtualMethod(QTextStream& out, const QString& className, const Method& meth)
{
    QString x_params, x_list;
    QString type = meth.type()->toString();
    out << "    virtual " << type << " " << meth.name() << "(";
    for (int i = 0; i < meth.parameters().count(); i++) {
        if (i > 0) { out << ", "; x_list.append(", "); }
        const Parameter& param = meth.parameters()[i];
        out << param.type()->toString() << " x" << i + 1;
        x_params += QString("        x[%1].%2 = x%1;\n").arg(QString::number(i + 1), stackItemField(param.type()));
        x_list += "x" + QString::number(i + 1);
    }
    out << ") {\n";
    out << QString("        Smoke::StackItem x[%1];\n").arg(meth.parameters().count() + 1);
    out << x_params;
    out << QString("        if (this->_binding->callMethod(%1, (void*)this, x)) return").arg(0);
    if (meth.type() == Type::Void) {
        out << ";\n";
    } else {
        out << QString(" (%1)x[0].%2;\n").arg(type, stackItemField(meth.type()));
    }
    out << QString("        this->%1::%2(%3);\n").arg(className).arg(meth.name()).arg(x_list);
    out << "    }\n";
}

QList<const Method*> collectVirtualMethods(const Class* klass)
{
    QList<const Method*> methods;
    foreach (const Method& meth, klass->methods()) {
        if ((meth.flags() & Method::Virtual || meth.flags() & Method::PureVirtual) && !meth.isDestructor())
            methods << &meth;
    }
    foreach (const Class::BaseClassSpecifier& baseClass, klass->baseClasses()) {
        methods.append(collectVirtualMethods(baseClass.baseClass));
    }
    return methods;
}

void writeClass(QTextStream& out, const Class* klass)
{
    const QString className = klass->toString();
    const QString smokeClassName = QString(className).replace("::", "__");
    
    out << QString("class x_%1 : public %2 {\n").arg(smokeClassName).arg(className);
    out << "    SmokeBinding* _binding;\n";
    out << "public:\n";
    for(int i = 0; i < klass->methods().count(); i++) {
        const Method& meth = klass->methods()[i];
        generateMethod(out, className, meth, i);
    }
    foreach (const Method* meth, collectVirtualMethods(klass)) {
        generateVirtualMethod(out, className, *meth);
    }
    out << "}\n\n";
}
